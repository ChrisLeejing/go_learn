1. 并发与并行:
    并发: 多个线程作用在一个CPU上, 比如: 运行10个线程, 每个线程执行10毫秒(轮训方式). 从宏观人的角度看, 10个线程都在运行, 从微观计算机的角度看, 在某个特定的时间点, 只有一个线程在执行, 这就是并发.
    并行: 多个线程作用在多个CPU上, 比如: 10个CPU运行10个线程, 假设每个线程都在各自不同的CPU上运行, 在某个特定的时间点, 不管是从宏观还是微观角度, 都同时有10个线程同时执行, 这就是并行.
2. go主线程与协程:
    go主线程(线程/进程), 在一个go线程中, 可以启动多个协程, 可以理解为: 在go中, 协程是轻量级的线程.
    go协程特点:
        1. 协程有独立的栈空间.
        2. 多个协程共享程序的堆空间.
        3. 协程的调度由用户控制.
        4. 协程是轻量级的线程.
3. goruntine的调度模型: MPG.
    M(OS thread, Machine): 操作系统的主线程(物理线程).
    P(Processor, abstract concept): go协程执行所需要的上下文.
    G(Goroutine): go协程.
    针对于MPG-1.png来说, 有以下几点: 
    * 图中显示有3个M(主线程), 如果3个M(主线程)同时作用在1个CPU上, 称为并发; 3个M(主线程)同时作用在3个CPU上, 称为并行. 
    * M1, M2, M3都正在执行一个G, M1的协程队列有3个,  M2的协程队列有3个, M3的协程队列有2个. 
    * 从图中可以看出, Go协程是一种轻量级线程, 是一种逻辑态, Go可以轻松开启上万个协程. 
    * 其他程序C/Java的多线程, 往往是内核态, 较为重量级, 几千个线程都可能耗光CPU资源. 
    
    针对于MPG-2.png来说, 分成左右两部分来看, 有以下几点: 
    * 原来的情况是M0主线程正在执行G0协程, 另外, 有3个协程正在等待. 
    * 如果G0协程阻塞, 比如: 正在执行读取文件或者数据库. 
    * 这时就会创建M1主线程(也可能是从已有的线程池中取出M1), 并且将等待的3个协程挂到M1下开始执行, M0的主线程下的G0仍然执行文件io的读写或者数据库操作.
    * 这样的MPG调度模式, 可以既让G0执行, 同时也不会让队列的其它协程一直阻塞, 仍然可以并发/并行执行.
    * 等到G0不阻塞了, M0会被放到空闲的主线程继续执行(从已有的线程池中取), 同时G0又会被唤醒.
    